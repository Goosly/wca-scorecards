{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar average_1 = require(\"./average\");\nfunction rank(results, rankingOrder) {\n  var averageCache = {};\n  var bestCache = {};\n  // first calc bests and averages where applicable\n  results.forEach(function (r) {\n    var plain = r.attempts.map(function (a) {\n      return a.result;\n    });\n    if (rankingOrder.indexOf('average') > -1) {\n      var average = r.attempts.length === 5 ? average_1.Ao5(plain) : average_1.Mo3(plain);\n      if (average < 0) {\n        average = Number.MAX_VALUE; // average can only be DNF, so no need to distinguish between DNF and DNS\n      }\n\n      averageCache[r.personId] = average;\n    }\n    var valid = plain.map(function (x) {\n      return parseInt(\"\" + x, 10);\n    }).filter(function (x) {\n      return x > 0;\n    });\n    if (valid.length > 0) {\n      bestCache[r.personId] = Math.min.apply(Math, valid);\n    }\n  });\n  // then order the results\n  results.sort(function (a, b) {\n    for (var i = 0; i < rankingOrder.length; i++) {\n      switch (rankingOrder[i]) {\n        case 'average':\n          if (averageCache[a.personId] && averageCache[b.personId]) {\n            if (averageCache[a.personId] < averageCache[b.personId]) return -1;\n            if (averageCache[a.personId] > averageCache[b.personId]) return 1;\n          }\n          if (averageCache[a.personId] && !averageCache[b.personId]) return -1;\n          if (!averageCache[a.personId] && averageCache[b.personId]) return 1;\n          break;\n        case 'single':\n          if (bestCache[a.personId] && bestCache[b.personId]) {\n            if (bestCache[a.personId] < bestCache[b.personId]) return -1;\n            if (bestCache[a.personId] > bestCache[b.personId]) return 1;\n          }\n          if (bestCache[a.personId] && !bestCache[b.personId]) return -1;\n          if (!bestCache[a.personId] && bestCache[b.personId]) return 1;\n      }\n    }\n    // neither has a better average or single, so normally we'd sort by name here\n    // as name is unavailable here however, we'll sort by personId, as that's all we have...\n    if (a.personId < b.personId) return -1;\n    if (a.personId > b.personId) return 1;\n    return 0;\n  });\n  // then calculate and set rankings\n  var currentRanking = 1;\n  var numWithCurrentRanking = 0;\n  results.forEach(function (result, ix) {\n    if (ix > 0) {\n      // compare with previous to see if we start a new ranking, or if this is the same ranking\n      var sameRanking_1 = true;\n      var cpid_1 = result.personId;\n      var ppid_1 = results[ix - 1].personId;\n      rankingOrder.forEach(function (ro) {\n        switch (ro) {\n          case 'average':\n            if (averageCache[cpid_1] !== averageCache[ppid_1]) sameRanking_1 = false;\n            break;\n          case 'single':\n            if (bestCache[cpid_1] !== bestCache[ppid_1]) sameRanking_1 = false;\n            break;\n        }\n      });\n      if (!sameRanking_1) {\n        currentRanking += numWithCurrentRanking;\n        numWithCurrentRanking = 0;\n      }\n    }\n    result.ranking = currentRanking;\n    numWithCurrentRanking++;\n  });\n  // now return the results ordered and with ranking applied\n  return results;\n}\nexports.rank = rank;\n//# sourceMappingURL=ranking.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}